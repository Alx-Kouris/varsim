package com.bina.varsim.tools.evaluation;

import com.bina.varsim.constants.Constant;
import com.bina.intervalTree.SimpleInterval1D;
import com.bina.intervalTree.ValueInterval1D;
import com.bina.varsim.types.*;
import com.bina.varsim.types.constraint.UnsatisfiedConstraintException;
import com.bina.varsim.types.stats.EnumStatsRatioCounter;
import com.bina.varsim.types.stats.StatsNamespace;
import com.bina.varsim.types.variant.Variant;
import com.bina.varsim.types.variant.VariantOverallType;
import com.bina.varsim.types.variant.VariantType;
import com.bina.varsim.util.ConstraintValidator;
import com.bina.varsim.util.SimpleReference;
import com.bina.varsim.util.VCFparser;
import com.bina.varsim.util.chrSearchTree;
import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.apache.commons.io.FileUtils;
import org.apache.log4j.Logger;
import org.kohsuke.args4j.Argument;
import org.kohsuke.args4j.CmdLineException;
import org.kohsuke.args4j.CmdLineParser;
import org.kohsuke.args4j.Option;

import java.io.File;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.*;

/**
 * Compare two VCF files, output the TPR and FDR for various bins and variant types
 * <p>
 * TODO: this file needs massive refactoring
 *
 * @author johnmu
 */

// TODO this class does not yet compare the contents of the larger variants
    //TODO refactor variable naming
public class VCFcompare {
    static final double OVERLAP_ARG = 0.8;
    static final int WIGGLE_ARG = 20;
    private final static Logger log = Logger.getLogger(VCFcompare.class.getName());

    @Option(name = "-reference", usage = "Reference Genome, specificity will be computed if provided", metaVar = "file")
    String reference;

    @Option(name = "-true_vcf", usage = "Truth VCF file generated by VarSim [Required]", metaVar = "file", required = true)
    String trueVcfFilename;

    @Argument(usage = "One or more VCF files from secondary analysis", metaVar = "vcf_files ...", required = true)
    ArrayList<String> newVcfFilename;

    @Option(name = "-prefix", usage = "Prefix for output file [Required]", metaVar = "file", required = true)
    String outPrefix;

    @Option(name = "-over", usage = "Reciprocal overlap ratio allowance in validation [" + OVERLAP_ARG + "]")
    double overlapRatio = OVERLAP_ARG;

    @Option(name = "-wig", usage = "Wiggle allowance in validation [" + WIGGLE_ARG + "]")
    int wiggle = WIGGLE_ARG;

    @Option(name = "-ignore_ins_len", usage = "Ignores insertion length when comparing")
    boolean ignoreInsertionLength = false;

    @Option(name = "-match_geno", usage = "Also ensures genotypes match")
    boolean matchGenotype = false;

    @Option(name = "-bed", usage = "BED file to restrict the analysis [Optional]", metaVar = "BED_file")
    String bedFilename = "";

    @Option(name = "-bed_exclude_tpr", usage = "Exclude TPR from the BED file filtering")
    boolean excludeTprFromBedFiltering;

    @Option(name = "-bed_exclude_fdr", usage = "Exclude FDR from the BED file filtering")
    boolean excludeFdfFromBedFiltering;

    @Option(name = "-bed_either", usage = "Use either break-end of the variant for filtering instead of both")
    boolean bedEither;

    @Option(name = "-html", usage = "Insert JSON to HTML file [Optional, internal]", metaVar = "HTML_file", hidden = true)
    File htmlFile = null;

    @Option(name = "-sample", usage = "Sample to read from new VCF, otherwise will read first one [Optional]", metaVar = "String")
    String sampleName = null;

    @Option(name = "-exclude_filtered", usage = "Exclude filtered variants. Will only load variants with '.' or 'PASS' in the FILTER column")
    boolean excludeFiltered = false;

    @Option(name = "-include_chr", usage = "Comma separated list of chromosomes to include, default is include all", metaVar = "CHR_LIST")
    String chromosomeToBeIncluded = null;

    @Option(name = "-con", usage = "One or more constraints on the accuracy of the output", metaVar = "CONSTRAINT")
    List<String> constraintArgs = null;

    public static void main(String[] args) {
        new VCFcompare().run(args);
    }

    /**
     * canonicalize to indels
     * @param canonicalVariantList where results are saved
     * @param alleleLengthDifference
     * @param reference
     * @param alternativeAlleles
     * @param variant
     * @param currentPosition
     * @param end should we append indels to the end?
      */
    private void canonicalizeToIndels(List<Variant> canonicalVariantList, int[] alleleLengthDifference, byte[] reference, byte[][] alternativeAlleles,
                                      Variant variant, int currentPosition, boolean end) {
        // add insertions or deletions for complex variants
        if (alleleLengthDifference[0] == alleleLengthDifference[1] && alleleLengthDifference[0] != 0) {
            // homozygous
            if (alleleLengthDifference[0] > 0) {
                // insertion
                if (Arrays.equals(alternativeAlleles[0], alternativeAlleles[1])) {
                    byte[] phase = {1, 1};

                    if (end) {
                        canonicalVariantList.add(new Variant(variant.getChr(), currentPosition + reference.length, 0, new byte[0],
                                new FlexSeq[]{new FlexSeq(Arrays.copyOfRange(alternativeAlleles[0], 0, alleleLengthDifference[0]))},
                                phase, true, variant.getVariantId(), VCFparser.DOT, ""));
                    } else {
                        canonicalVariantList.add(new Variant(variant.getChr(), currentPosition, 0, new byte[0],
                                new FlexSeq[]{new FlexSeq(Arrays.copyOfRange(alternativeAlleles[0], 0, alleleLengthDifference[0]))},
                                phase, true, variant.getVariantId(), VCFparser.DOT, ""));
                    }
                } else {
                    byte[] phase = {0, 0};
                    if (end) {
                        phase[0] = 1;
                        phase[1] = 0;
                        canonicalVariantList.add(new Variant(variant.getChr(), currentPosition + reference.length, 0, new byte[0],
                                new FlexSeq[]{new FlexSeq(Arrays.copyOfRange(alternativeAlleles[0], 0, alleleLengthDifference[0]))},
                                phase, true, variant.getVariantId(), VCFparser.DOT, ""));
                        phase[0] = 0;
                        phase[1] = 1;
                        canonicalVariantList.add(new Variant(variant.getChr(), currentPosition + reference.length, 0, new byte[0],
                                new FlexSeq[]{new FlexSeq(Arrays.copyOfRange(alternativeAlleles[1], 0, alleleLengthDifference[1]))},
                                phase, true, variant.getVariantId(), VCFparser.DOT, ""));
                    } else {
                        phase[0] = 1;
                        phase[1] = 0;
                        canonicalVariantList.add(new Variant(variant.getChr(), currentPosition, 0, new byte[0],
                                new FlexSeq[]{new FlexSeq(Arrays.copyOfRange(alternativeAlleles[0], 0, alleleLengthDifference[0]))},
                                phase, true, variant.getVariantId(), VCFparser.DOT, ""));
                        phase[0] = 0;
                        phase[1] = 1;
                        canonicalVariantList.add(new Variant(variant.getChr(), currentPosition, 0, new byte[0],
                                new FlexSeq[]{new FlexSeq(Arrays.copyOfRange(alternativeAlleles[1], 0, alleleLengthDifference[1]))},
                                phase, true, variant.getVariantId(), VCFparser.DOT, ""));
                    }
                }
            } else if (alleleLengthDifference[0] < 0) {
                //here both alternative alleles are shorter than the reference allele
                // deletion
                byte[] phase = {1, 1};
                //VarSim will try adding indels both to left end and to right end
                if (end) {
                    canonicalVariantList.add(new Variant(variant.getChr(), currentPosition + alternativeAlleles[0].length, -alleleLengthDifference[0],
                            Arrays.copyOfRange(reference, alternativeAlleles[0].length, alternativeAlleles[0].length - alleleLengthDifference[0]), new FlexSeq[]{new FlexSeq()},
                            phase, true, variant.getVariantId(), VCFparser.DOT, ""));
                } else {
                    canonicalVariantList.add(new Variant(variant.getChr(), currentPosition, -alleleLengthDifference[0],
                            Arrays.copyOfRange(reference, 0, -alleleLengthDifference[0]), new FlexSeq[]{new FlexSeq()},
                            phase, true, variant.getVariantId(), VCFparser.DOT, ""));
                }
            }
        } else {
            for (int a = 0; a < alternativeAlleles.length; a++) {
                if (alleleLengthDifference[a] > 0) {
                    // insertion
                    byte[] phase = {0, 0};
                    phase[a] = 1;
                    if (end) {
                        canonicalVariantList.add(new Variant(variant.getChr(), currentPosition + reference.length, 0, new byte[0],
                                new FlexSeq[]{new FlexSeq(Arrays.copyOfRange(alternativeAlleles[a], 0, alleleLengthDifference[a]))},
                                phase, true, variant.getVariantId(), VCFparser.DOT, ""));
                    } else {
                        canonicalVariantList.add(new Variant(variant.getChr(), currentPosition, 0, new byte[0],
                                new FlexSeq[]{new FlexSeq(Arrays.copyOfRange(alternativeAlleles[a], 0, alleleLengthDifference[a]))},
                                phase, true, variant.getVariantId(), VCFparser.DOT, ""));
                    }
                } else if (alleleLengthDifference[a] < 0) {
                    // deletion
                    byte[] phase = {0, 0};
                    phase[a] = 1;
                    if (end) {
                        canonicalVariantList.add(new Variant(variant.getChr(), currentPosition + alternativeAlleles[a].length, -alleleLengthDifference[a],
                                Arrays.copyOfRange(reference, alternativeAlleles[a].length, alternativeAlleles[a].length - alleleLengthDifference[a]), new FlexSeq[]{new FlexSeq()},
                                phase, true, variant.getVariantId(), VCFparser.DOT, ""));
                    } else {
                        canonicalVariantList.add(new Variant(variant.getChr(), currentPosition, -alleleLengthDifference[a],
                                Arrays.copyOfRange(reference, 0, -alleleLengthDifference[a]), new FlexSeq[]{new FlexSeq()},
                                phase, true, variant.getVariantId(), VCFparser.DOT, ""));
                    }
                }
            }
        }
    }

    /**
     * wrapper for variant canonicalization (conversion to indels + SNPs)
     * VarSim will convert regular variants into normalized variants, i.e. insertion,deletion
     * plus SNPs. It will try placing insertions and deletions at both beginning and end of
     * a variant and pick the placement with fewest # of mismatches (normalized variants).
     *
     * @param var
     * @return
     */
    private List<Variant> canonicalizeVariant(Variant var) {
      /*
      why do we need to create a copy of variant?
      because we will set it to reference allele
      after canonicalization.
       */
        //not adding indels to the end
        List<Variant> variantList = canonicalizeVariant(new Variant(var), false);
        //try adding indels to the end
        List<Variant> variantListEnd = canonicalizeVariant(new Variant(var), true);
        if (variantListEnd.size() < variantList.size()) {
            variantList = variantListEnd;
        }
        return variantList;
    }

    /**
     * actual implementation for canonicalization
     * @param variant
     * @param end
     * @return
     */
    //if end = true, we add indels to the end
    private List<Variant> canonicalizeVariant(Variant variant, boolean end) {
        List<Variant> variantList = new ArrayList<>();

        //System.err.println("pat|mat: " + var.paternal() +"|"+ var.maternal());
        // if the variant is an MNP or SNP, break it dooooownnn

        boolean noSplit = false;
        if (variant.getType() == VariantOverallType.SNP) {
            noSplit = true;
        }
        //both alleles are reference alleles
        if (variant.getGoodPaternal() == 0 && variant.getGoodMaternal() == 0) {
            noSplit = true;
        }
        //paternal allele is not reference or sequence
        if (variant.getGoodPaternal() > 0 && variant.getAlt(variant.getGoodPaternal()).getType() != FlexSeq.Type.SEQ) {
            noSplit = true;
        }
        //maternal allele is not reference or sequence
        if (variant.getGoodMaternal() > 0 && variant.getAlt(variant.getGoodMaternal()).getType() != FlexSeq.Type.SEQ) {
            noSplit = true;
        }
        //paternal allele is not reference and has zero-length allele and reference sequence
        if (variant.getGoodPaternal() > 0 && variant.getAlt(variant.getGoodPaternal()).length() == 0 && variant.getReference().length == 0) {
            noSplit = true;
        }
        //maternal allele is not reference and has zero-length allele and reference sequence
        if (variant.getGoodMaternal() > 0 && variant.getAlt(variant.getGoodMaternal()).length() == 0 && variant.getReference().length == 0) {
            noSplit = true;
        }

        if (noSplit) {
            variantList.add(variant);
            return variantList;
        }


        //split long variants into small ones for unambiguous comparison
        if (variant.getType(variant.getGoodPaternal()) != VariantType.Reference
                && variant.getType(variant.getGoodMaternal()) != VariantType.Reference) {

            //0 for reference, 1 for 1st alt allele, 2 for 2nd alt allele
            int[] alleleNumber = {variant.getAllele(0), variant.getAllele(1)};
            byte[][] alternativeAlleleSequence = {variant.getAlt(alleleNumber[0]).getSequence(), variant.getAlt(alleleNumber[1]).getSequence()};
            byte[] referenceAlleleSequence = variant.getReference();
            int currentPosition = variant.getPos();

            // modify positions based on if ref matches alt
            int minMatchLength = variant.getMinMatchLength();

            /*
            reference   ******|------
            paternal    ******|--
            maternal    ******|------

            we will right-shift the variant to remove redundancy with the reference
            */
            if (minMatchLength > 0) {
                //remove redundancy in reference
                referenceAlleleSequence = Arrays.copyOfRange(referenceAlleleSequence, minMatchLength, referenceAlleleSequence.length);
                //remove redundancy in alternative alleles
                for (int i = 0; i < 2; i++) {
                    alternativeAlleleSequence[i] = Arrays.copyOfRange(alternativeAlleleSequence[i], minMatchLength, alternativeAlleleSequence[i].length);
                }
                currentPosition += minMatchLength;
            }

            //length difference between reference and allele
            int[] alleleLengthDifference = {alternativeAlleleSequence[0].length - referenceAlleleSequence.length,
                                            alternativeAlleleSequence[1].length - referenceAlleleSequence.length};

            /*
            convert the variant into insertion/deletion + SNPs
             */
            canonicalizeToIndels(variantList, alleleLengthDifference, referenceAlleleSequence, alternativeAlleleSequence, variant, currentPosition, end);

          /*
          iterate over reference bp, note here the reference has been adjusted to
          remove redudancy. Create SNPs (for canonicalization) wherever there are
          mismatches.
           */
            for (int relativePosition = 0; relativePosition < referenceAlleleSequence.length; relativePosition++, currentPosition++) {

                //relative position on alleles (adjusted for insertions/deletions)
                int[] alleleSpecificRelativePosition = new int[2];
                if (end) {
                    //TODO: there are many places a for loop over 0,1 is used to iterate over all genotypes, maybe it's better to use an immutable data structure
                    for (int j = 0; j < 2; j++) {
                      //recall: diff[j] = alt[j].length - ref.length
                        if (relativePosition < referenceAlleleSequence.length + alleleLengthDifference[j]) {
                            alleleSpecificRelativePosition[j] = relativePosition;
                        } else {
                            alleleSpecificRelativePosition[j] = -1; // we are into deleted bases
                        }
                    }
                } else {
                    for (int j = 0; j < 2; j++) {
                        //this one dictates that canonicalized variants will be located on the right end of reference allele
                        alleleSpecificRelativePosition[j] = relativePosition + alleleLengthDifference[j];
                    }
                }

                if (alleleSpecificRelativePosition[0] < 0 && alleleSpecificRelativePosition[1] < 0) {
                    // both deleted
                    /*
                    AGG
                    --G
                    --G
                    ^    the scenario this if statement deals with
                     */
                } else if (alleleSpecificRelativePosition[0] >= 0 && alleleSpecificRelativePosition[1] < 0 &&
                           alternativeAlleleSequence[0][alleleSpecificRelativePosition[0]] != referenceAlleleSequence[relativePosition]) {
                    /* one deleted, hence the other is homozygous
                    e.g. ref: AGG, alts: C,CT
                    if we visualize the alignment, it looks like
                    AGG
                    -CT
                    --C
                     ^  the scenario this if statement deals with
                    */
                    byte[] phase = {1, 1};
                    variantList.add(new Variant(variant.getChr(), currentPosition, 1, new byte[]{referenceAlleleSequence[relativePosition]},
                            new FlexSeq[]{new FlexSeq(alternativeAlleleSequence[0][alleleSpecificRelativePosition[0]])}, phase, true, variant.getVariantId(), VCFparser.DOT, ""));
                } else if (alleleSpecificRelativePosition[0] < 0 && alleleSpecificRelativePosition[1] >= 0 &&
                        alternativeAlleleSequence[1][alleleSpecificRelativePosition[1]] != referenceAlleleSequence[relativePosition]) {
                    // one deleted, hence the other is homozygous
                    //same as above but two alleles switch
                    byte[] phase = {1, 1};
                    variantList.add(new Variant(variant.getChr(), currentPosition, 1, new byte[]{referenceAlleleSequence[relativePosition]},
                            new FlexSeq[]{new FlexSeq(alternativeAlleleSequence[1][alleleSpecificRelativePosition[1]])}, phase, true, variant.getVariantId(), VCFparser.DOT, ""));
                } else if (alleleSpecificRelativePosition[0] >= 0 && alleleSpecificRelativePosition[1] < 0 &&
                           alternativeAlleleSequence[0][alleleSpecificRelativePosition[0]] == referenceAlleleSequence[relativePosition]) {
                    // ref call with del
                  /*
                    AGG
                    -GT
                    --C
                     ^  the scenario this if statement deals with
                    */
                } else if (alleleSpecificRelativePosition[0] < 0 && alleleSpecificRelativePosition[1] >= 0 &&
                        alternativeAlleleSequence[1][alleleSpecificRelativePosition[1]] == referenceAlleleSequence[relativePosition]) {
                    // ref call with del
                  //same as above but switch alleles
                } else if (alternativeAlleleSequence[0][alleleSpecificRelativePosition[0]] == referenceAlleleSequence[relativePosition] &&
                        alternativeAlleleSequence[1][alleleSpecificRelativePosition[1]] == referenceAlleleSequence[relativePosition]) {
                    // ref call
                  /*
                    AGG
                    -GG
                    --G
                      ^  the scenario this if statement deals with
                    */
                } else if (alternativeAlleleSequence[0][alleleSpecificRelativePosition[0]] == alternativeAlleleSequence[1][alleleSpecificRelativePosition[1]]) {
                    // homozygous non-reference alleles
                  /*
                    AGG
                    -GC
                    --C
                      ^  the scenario this if statement deals with
                    */
                    byte[] phase = {1, 1};
                    variantList.add(new Variant(variant.getChr(), currentPosition, 1, new byte[]{referenceAlleleSequence[relativePosition]},
                            new FlexSeq[]{new FlexSeq(alternativeAlleleSequence[0][alleleSpecificRelativePosition[0]])}, phase, true, variant.getVariantId(), VCFparser.DOT, ""));
                } else if (alternativeAlleleSequence[0][alleleSpecificRelativePosition[0]] != referenceAlleleSequence[relativePosition] &&
                        alternativeAlleleSequence[1][alleleSpecificRelativePosition[1]] != referenceAlleleSequence[relativePosition]) {
                    // het but both alt
                  /*
                    AGG
                    -GC
                    --T
                      ^  the scenario this if statement deals with
                    */
                    byte[] phase = {1, 2};
                    variantList.add(new Variant(variant.getChr(), currentPosition, 1, new byte[]{referenceAlleleSequence[relativePosition]},
                            new FlexSeq[]{new FlexSeq(alternativeAlleleSequence[0][alleleSpecificRelativePosition[0]]), new FlexSeq(alternativeAlleleSequence[1][alleleSpecificRelativePosition[1]])},
                            phase, true, variant.getVariantId(), VCFparser.DOT, ""));
                } else {
                    // het with one ref
                  /*
                    AGG
                    -GG
                    --T
                      ^  the scenario this if statement deals with
                    */
                    for (int a = 0; a < 2; a++) {
                        if (alternativeAlleleSequence[a][alleleSpecificRelativePosition[a]] != referenceAlleleSequence[relativePosition]) {
                            byte[] phase = {0, 0};
                            phase[a] = 1;
                            variantList.add(new Variant(variant.getChr(), currentPosition, 1, new byte[]{referenceAlleleSequence[relativePosition]},
                                    new FlexSeq[]{new FlexSeq(alternativeAlleleSequence[a][alleleSpecificRelativePosition[a]])}, phase, true, variant.getVariantId(), VCFparser.DOT, ""));
                        }
                    }
                }

            }
            variant.setAllele(0, (byte) 0); // set to reference
            variant.setAllele(1, (byte) 0); // set to reference
        } else {
            //at least one of paternal and maternal alleles is not reference
            for (int alleleIndex = 0; alleleIndex < 2; alleleIndex++) {
                int allele = variant.getAllele(alleleIndex);
                //only process Complex, MNP and SNP variants
                if (variant.getType(allele) == VariantType.Complex
                        || variant.getType(allele) == VariantType.MNP
                        || variant.getType(allele) == VariantType.SNP) {
                    byte[] alternativeAlleleSequence = variant.getAlt(allele).getSequence();
                    byte[] referenceSequence = variant.getReference();
                    int currentPosition = variant.getPos();
                    int alleleLengthDifference = alternativeAlleleSequence.length - referenceSequence.length;

                    // add insertions or deletions for complex variants

                    if (alleleLengthDifference > 0) {
                        // insertion
                        byte[] phase = {0, 0};
                        phase[alleleIndex] = 1;
                        if (end) {
                            variantList.add(new Variant(variant.getChr(), currentPosition + referenceSequence.length, 0, new byte[0],
                                    new FlexSeq[]{new FlexSeq(Arrays.copyOfRange(alternativeAlleleSequence, 0, alleleLengthDifference))},
                                    phase, true, variant.getVariantId(), VCFparser.DOT, ""));
                        } else {
                            variantList.add(new Variant(variant.getChr(), currentPosition, 0, new byte[0],
                                    new FlexSeq[]{new FlexSeq(Arrays.copyOfRange(alternativeAlleleSequence, 0, alleleLengthDifference))},
                                    phase, true, variant.getVariantId(), VCFparser.DOT, ""));
                        }
                    } else if (alleleLengthDifference < 0) {
                        // deletion
                        byte[] phase = {0, 0};
                        phase[alleleIndex] = 1;
                        if (end) {
                            variantList.add(new Variant(variant.getChr(), currentPosition + alternativeAlleleSequence.length, -alleleLengthDifference,
                                    Arrays.copyOfRange(referenceSequence, alternativeAlleleSequence.length, alternativeAlleleSequence.length - alleleLengthDifference),
                                    new FlexSeq[]{new FlexSeq()},
                                    phase, true, variant.getVariantId(), VCFparser.DOT, ""));
                        } else {
                            variantList.add(new Variant(variant.getChr(), currentPosition, -alleleLengthDifference,
                                    Arrays.copyOfRange(referenceSequence, 0, -alleleLengthDifference),
                                    new FlexSeq[]{new FlexSeq()},
                                    phase, true, variant.getVariantId(), VCFparser.DOT, ""));
                        }
                    }

                    for (int i = 0; i < referenceSequence.length; i++) {
                        int idx;
                        if (end) {
                            if (i < referenceSequence.length + alleleLengthDifference) {
                                idx = i;
                            } else {
                                idx = -1; // we are in a deleted region
                            }
                        } else {
                            idx = i + alleleLengthDifference;
                        }

                        if (idx >= 0 && alternativeAlleleSequence[idx] != referenceSequence[i]) {
                            byte[] phase = {0, 0};
                            phase[alleleIndex] = 1;

                            variantList.add(new Variant(variant.getChr(), currentPosition, 1, new byte[]{referenceSequence[i]},
                                    new FlexSeq[]{new FlexSeq(alternativeAlleleSequence[idx])}, phase, true, variant.getVariantId(), VCFparser.DOT, ""));
                        }

                        currentPosition++;
                    }

                    variant.setAllele(alleleIndex, (byte) 0); // set to reference
                }
            }
        }

        if (!variant.isRef()) {
            variantList.add(variant);
        }

        return variantList;
    }

    /**
     * Main method
     */
    public void run(String[] args) {
        String VERSION = "VarSim " + getClass().getPackage().getImplementationVersion();
        String usage = "Generates a JSON with accuracy statistics of a VCF file relative to a truth\n";

        System.err.println(VERSION);

        // these are the statistics we "ideally" want to collect
        // number of variants correct (either genotype) (for each type)
        // number homozygous correct (for each type)
        // number heterozygous correct (for each type)
        // number homozygous genotype correct (for each type)
        // number heterozyous genotype correct (for each type)

        CmdLineParser parser = new CmdLineParser(this);

        // if you have a wider console, you could increase the value;
        // here 80 is also the default
        parser.setUsageWidth(80);

        try {
            parser.parseArgument(args);
        } catch (CmdLineException e) {
            System.err.println(e.getMessage());
            System.err.println("java -jar VarSim.jar vcfcompare [options...] vcf_files ...");
            // print the list of available options
            parser.printUsage(System.err);
            System.err.println(usage);
            return;
        }

        BedFile intersector = null;
        boolean bed_exists = false;
        // check if the file exists
        try {
            File f = new File(bedFilename);
            if (f.exists()) {
                bed_exists = true;
            }
        } catch (Exception e) {
            e.printStackTrace();
        }

        if (bed_exists) {
            log.info("Using " + bedFilename + " to intersect");
            intersector = new BedFile(bedFilename);
        } else {
            if (excludeTprFromBedFiltering || excludeFdfFromBedFiltering) {
                log.warn("No BED file specified but used exclude parameters");
            }
        }

        Set<String> chrAcceptor = null;
        //TODO: make chrAcceptor a class
        if (chromosomeToBeIncluded != null) {
            chrAcceptor = new HashSet<>(Arrays.asList(chromosomeToBeIncluded.split(",")));
            log.info("Only accepting chromosomes: " + Arrays.toString(chrAcceptor.toArray()));
        }

        ConstraintValidator validator = new ConstraintValidator(constraintArgs);

        // Load refernece genome
        SimpleReference referenceGenome = reference == null ? null : new SimpleReference(reference);

        // load true VCF into interval tree
        log.info("Load Truth VCF");

        /**
         * This is just for outputting to JSON
         */
        class outputClass {
            CompareParams params;
            EnumStatsRatioCounter<VariantOverallType> num_true_correct;

            outputClass(CompareParams params, EnumStatsRatioCounter<VariantOverallType> num_true_correct) {
                this.params = params;
                this.num_true_correct = num_true_correct;
            }

            outputClass() {
            }

            public CompareParams getParams() {
                return params;
            }

            public void setParams(CompareParams params) {
                this.params = params;
            }

            public EnumStatsRatioCounter<VariantOverallType> getNum_true_correct() {
                return num_true_correct;
            }

            public void setNum_true_correct(EnumStatsRatioCounter<VariantOverallType> num_true_correct) {
                this.num_true_correct = num_true_correct;
            }
        }


        outputClass outputBlob = new outputClass();

        outputBlob.setParams(new CompareParams());
        outputBlob.getParams().setBed_filename(bedFilename);
        // TODO: make it output the full list if variants in JSON
        outputBlob.getParams().setNew_vcf_filename(newVcfFilename.get(0));
        outputBlob.getParams().setOverlap_percent(overlapRatio);
        outputBlob.getParams().setTrue_vcf_filename(trueVcfFilename);
        outputBlob.getParams().setWiggle(wiggle);

        VCFparser true_parser = new VCFparser(trueVcfFilename, null, false);

        // allow duplicates, this is needed because insertions don't actually take up a location
        chrSearchTree<ValueInterval1D<Variant>> trueVariantIntervalTree = new chrSearchTree<>(true);
        int numRead = 0;
        int numAdded = 0;

        // this is for the original variants
        // it stores the total length of the original variant in bases
        // Still check for validation of canonical full variants
        ArrayList<Integer> full_validated_total = new ArrayList<>();
        ArrayList<Variant> true_var_list = new ArrayList<>();

        // For each true variant, if the number of bases validated is over a certain threshold
        // call it correct
        outputBlob.setNum_true_correct(new EnumStatsRatioCounter<VariantOverallType>());

        // For called variants, break down into canonical ones and count based on that
        // if any called variant overlaps a complex variant or MNP, count it as "complex"
        // otherwise, simple count them in their canonical forms

        // store true variants as canonical ones, but remember original form
        while (true_parser.hasMoreInput()) {
            Variant var = true_parser.parseLine();
            if (var == null) {
                log.info("skip line");
                continue;
            }

            Genotypes geno = var.getGenotypes();

            if (!geno.isNonRef()) {
                continue;
            }

            ChrString chr = var.getChr();
            VariantOverallType orig_type = var.getType();

            if (chrAcceptor != null && !chrAcceptor.contains(chr.getName())) {
                continue;
            }

            // determine max variant region
            // when comparing genotypes, we need to individually compare
            // to make sure they really overlap

            //TODO: remove constructor here (because another copy will be created inside canonicalizeVariant
            List<Variant> var_list = canonicalizeVariant(new Variant(var));

            int total_len = 0;
            double max_len = 0;

            // add to interval tree
            for (Variant curr_var : var_list) {

                int curr_len = curr_var.maxLen();
                max_len = Math.max(max_len, curr_len);

                total_len += curr_len;
                SimpleInterval1D curr_var_reg = null;
                try {
                    curr_var_reg = curr_var.getGenotypeUnionVariantInterval();
                } catch (Exception e) {
                    e.printStackTrace();
                    log.error("Original variant: " + var);
                    log.error("Bad variant: " + curr_var);
                    System.exit(1);
                }
                curr_var.splitVariantIndex = numAdded;
                curr_var.wholeVariantIndex = numRead;
                curr_var.originalType = orig_type;

                trueVariantIntervalTree.put(chr, new ValueInterval1D<>(curr_var_reg, curr_var));
                numAdded++;
            }

            if (total_len >= Constant.SVLEN && max_len / total_len >= overlapRatio && var_list.size() > 1) {
                // in this case we break down the variant into canoical forms since
                // the original variant was probably a large deletion with a small insertion
                for (Variant curr_var : var_list) {
                    int curr_len = curr_var.maxLen();
                    full_validated_total.add(curr_len);
                    true_var_list.add(curr_var);
                    numRead++;
                }
            } else {
                full_validated_total.add(total_len);
                true_var_list.add(var);
                numRead++;
            }
        }

        log.info("Num read:  " + numRead);
        log.info("Num added: " + numAdded);
        log.info("Num nodes: " + trueVariantIntervalTree.size());
        log.info("Max depth: " + trueVariantIntervalTree.maxDepth());

        // this is for the split variants
        // set to true if the canonical original variant was validated true
        BitSet validatedTrue = new BitSet(numAdded);

        // this is for the original variants
        // count of the number of bases validated for the original variant
        int[] fullValidatedCount = new int[numRead];

        // generate the output files
        PrintWriter tpWriter = null;
        PrintWriter unknownTpWriter = null;
        PrintWriter fpWriter = null;
        PrintWriter unknownFpWriter = null;
        PrintWriter fnWriter = null;
        PrintWriter jsonWriter = null;
        try {
            tpWriter = new PrintWriter(outPrefix + "_TP.vcf", "UTF-8");
            unknownTpWriter = new PrintWriter(outPrefix + "_unknown_TP.vcf", "UTF-8");
            fpWriter = new PrintWriter(outPrefix + "_FP.vcf", "UTF-8");
            unknownFpWriter = new PrintWriter(outPrefix + "_unknown_FP.vcf", "UTF-8");
            fnWriter = new PrintWriter(outPrefix + "_FN.vcf", "UTF-8");
            jsonWriter = new PrintWriter(outPrefix + "_report.json", "UTF-8");
        } catch (Exception e) {
            e.printStackTrace();
            System.exit(1);
        }


        // for this case we add to false positives if the variant is not validated.
        // However, do don't add to true positives, those that computed later

        log.info("Load New VCF");
        int numberOfNewVariants = 0;
        // iterate over new VCF and collect stats

        for (String currentVcfFile : newVcfFilename) {
            VCFparser newParser = new VCFparser(currentVcfFile, sampleName, excludeFiltered);

            while (newParser.hasMoreInput()) {
                Variant variant = newParser.parseLine();

                //TODO: wrap variant comparison into a method for easier reading
                if (variant == null) {
                    // System.err.println("Bad variant or not a variant line");
                    continue;
                }

                Genotypes geno;

                ChrString chr = variant.getChr();

                if (chrAcceptor != null && !chrAcceptor.contains(chr.getName())) {
                    continue;
                }

                SimpleInterval1D variantInterval = variant.getGenotypeUnionAlternativeInterval();

                boolean skipFP = false;
                if (intersector != null) {
                    if (!excludeFdfFromBedFiltering && !intersector.containsEndpoints(chr, variantInterval, bedEither)) {
                        skipFP = true;
                    }
                }

                // the overall type of the called variant
                VariantOverallType currentVariantType = variant.getType();

                // if called as complex variant convert to indel+snps
                List<Variant> canonicalVariantList = canonicalizeVariant(variant);

                double totalLength = 0;
                double validatedLength = 0;
                double maxLength = 0;

                for (Variant currentVariant : canonicalVariantList) {
                    totalLength += currentVariant.maxLen();
                    maxLength = Math.max(maxLength, currentVariant.maxLen());
                }

                // split up variants that are basically one big variant and one small one
                boolean computeAsSplit = false;
                if (totalLength >= Constant.SVLEN && maxLength / totalLength >= overlapRatio &&
                    canonicalVariantList.size() > 1) {
                    computeAsSplit = true;
                }

                for (Variant currentVariant : canonicalVariantList) {
                    // get genotype
                    geno = currentVariant.getGenotypes();
                    //note here ResultComparator is created for each canonical variant
                    ResultComparator resultComparator = new ResultComparator(trueVariantIntervalTree, overlapRatio, wiggle, ignoreInsertionLength);

                    if (currentVariant.isHom()) {
                        int maxTrueLength = resultComparator.compareVariant(currentVariant, geno.geno[0], validatedTrue);
                        final DualIdx dualIdx = matchGenotype ? resultComparator.isHomMatch() : resultComparator.isMatch();
                        if (dualIdx.splitVariantIndex >= 0) {
                            // validated
                            validatedTrue.set(dualIdx.splitVariantIndex);
                            fullValidatedCount[dualIdx.wholeVariantIndex] += maxTrueLength;// this 'should' be overlap len
                            validatedLength += currentVariant.maxLen();
                        } else if (computeAsSplit) {
                            if (!skipFP) {
                                outputBlob.getNum_true_correct().incFP(currentVariant.getType(), variant.maxLen());
                                validator.inc(StatsNamespace.FP, currentVariant.getType(), variant.maxLen());
                                fpWriter.println(variant);
                            } else {
                                unknownFpWriter.println(variant);
                            }
                        }

                    } else {
                        // het
                        //boolean matched = false;
                        int maxTrueLen = 0;
                        /*
                        for heterozygous variants, all genotypes will be checked
                        inside compareVariant, all genotypes of overlapping true variants will be checked, too
                        so overall all possible combinations of genotype matching will be checked
                        */
                        for (int i = 0; i < 2; i++) {
                            byte allele = geno.geno[i];
                            if (allele > 0) {
                                maxTrueLen = Math.max(resultComparator.compareVariant(currentVariant, allele, validatedTrue), maxTrueLen);
                            }
                        }

                        final DualIdx dualIdx = matchGenotype ? resultComparator.isHetMatch() : resultComparator.isMatch();

                        if (dualIdx.splitVariantIndex >= 0) {
                            validatedTrue.set(dualIdx.splitVariantIndex);
                            fullValidatedCount[dualIdx.wholeVariantIndex] += currentVariant.maxLen(); // this 'should' be overlap len
                            validatedLength += currentVariant.maxLen();
                        } else if (computeAsSplit) {
                            if (!skipFP) {
                                outputBlob.getNum_true_correct().incFP(currentVariant.getType(), currentVariant.maxLen());
                                validator.inc(StatsNamespace.FP, currentVariant.getType(), currentVariant.maxLen());
                                if (currentVariant.getType() == VariantOverallType.SNP && currentVariant.maxLen() > 1) {
                                    log.warn("SNP with bad length: " + currentVariant);
                                }
                                fpWriter.println(variant);
                            } else {
                                unknownFpWriter.println(variant);
                            }
                        }
                    }
                }

                if (!computeAsSplit && validatedLength < (totalLength * overlapRatio)) {
                    if (!skipFP) {
                        // this is a false positive!
                        outputBlob.getNum_true_correct().incFP(currentVariantType, variant.maxLen());
                        validator.inc(StatsNamespace.FP, currentVariantType, variant.maxLen());
                        if (currentVariantType == VariantOverallType.SNP && variant.maxLen() > 1) {
                            log.warn("SNP with bad length: " + variant);
                        }
                        fpWriter.println(variant);
                    } else {
                        unknownFpWriter.println(variant);
                    }
                }

                numberOfNewVariants++;
            }
        }

        log.info("Num new variants read: " + numberOfNewVariants);

        // read through again and compute for the true variants
        int num_read2 = 0;
        for (Variant var : true_var_list) {

            ChrString chr = var.getChr();

            if (chrAcceptor != null && !chrAcceptor.contains(chr.getName())) {
                continue;
            }

            SimpleInterval1D curr_var_reg = var.getGenotypeUnionAlternativeInterval();

            if (intersector == null || excludeTprFromBedFiltering || intersector.containsEndpoints(chr, curr_var_reg, bedEither)) {
                int total_len = full_validated_total.get(num_read2);
                int validated_len = fullValidatedCount[num_read2];

                if (validated_len >= (overlapRatio * total_len)) {
                    // validated
                    outputBlob.getNum_true_correct().incTP(var.getType(), var.maxLen());
                    validator.inc(StatsNamespace.TP, var.getType(), var.maxLen());
                    tpWriter.println(var);
                } else {
                    fnWriter.println(var);
                }

                outputBlob.getNum_true_correct().incT(var.getType(), var.maxLen());
                validator.inc(StatsNamespace.T, var.getType(), var.maxLen());
            } else {
                unknownTpWriter.println(var);
            }
            num_read2++;
        }

        if (numRead != num_read2) {
            log.error("Number of variants read are inconsistent: " + numRead + "," + num_read2);
        }

        // Compute and update the true negatives here so that we have specificity values
        if (referenceGenome != null) {
            final VariantOverallType variantOverallTypes[] = {VariantOverallType.SNP, VariantOverallType.Insertion, VariantOverallType.Deletion};
            for (final VariantOverallType variantOverallType : variantOverallTypes) {
                if (outputBlob.getNum_true_correct().getData().containsKey(variantOverallType)) {
                    outputBlob.getNum_true_correct().getData().get(variantOverallType).computeTN((int) referenceGenome.getNumNonNBases());
                }
            }
        }


        // output the stats
        System.err.println(outputBlob.getNum_true_correct());

        ObjectMapper mapper = new ObjectMapper();
        mapper.configure(JsonGenerator.Feature.AUTO_CLOSE_TARGET, false);

        String jsonStr = "";
        try {
            jsonStr = mapper.writeValueAsString(outputBlob);
            jsonWriter.print(jsonStr);
        } catch (Exception e) {
            e.printStackTrace();
        }

        if (htmlFile != null) {
            try {
                FileUtils.writeStringToFile(new File(outPrefix + "_varcomp.html"),
                        JSONInserter.insertJSON(FileUtils.readFileToString(htmlFile), jsonStr));
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

        try {
            tpWriter.close();
            unknownTpWriter.close();
            fpWriter.close();
            unknownFpWriter.close();
            fnWriter.close();
            jsonWriter.close();
        } catch (Exception e) {
            e.printStackTrace();
        }

        // Check the validity
        try {
            validator.testValidity();
        } catch (UnsatisfiedConstraintException e) {
            log.error("A number of constraints were not satisfied:");
            for (UnsatisfiedConstraintException.valuePair constraint : e.getConstraints()) {
                log.error(String.format("%.4f : %s", constraint.getActualValue(), constraint.getConstraint()));
            }
            System.exit(1);
        }

        log.info("Done!"); // used to record the time
    }

    class CompareParams {
        String true_vcf_filename;
        String new_vcf_filename;
        Double overlap_ratio;
        int wiggle;
        String bed_filename;

        public CompareParams() {
        }

        public CompareParams(String true_vcf_filename, String new_vcf_filename, Double overlap_ratio, int wiggle, String bed_filename) {
            this.true_vcf_filename = true_vcf_filename;
            this.new_vcf_filename = new_vcf_filename;
            this.overlap_ratio = overlap_ratio;
            this.wiggle = wiggle;
            this.bed_filename = bed_filename;
        }


        public String getTrue_vcf_filename() {
            return true_vcf_filename;
        }

        public void setTrue_vcf_filename(String true_vcf_filename) {
            this.true_vcf_filename = true_vcf_filename;
        }

        public String getNew_vcf_filename() {
            return new_vcf_filename;
        }

        public void setNew_vcf_filename(String new_vcf_filename) {
            this.new_vcf_filename = new_vcf_filename;
        }

        public Double getOverlap_percent() {
            return overlap_ratio;
        }

        public void setOverlap_percent(Double overlap_ratio) {
            this.overlap_ratio = overlap_ratio;
        }

        public int getWiggle() {
            return wiggle;
        }

        public void setWiggle(int wiggle) {
            this.wiggle = wiggle;
        }

        public String getBed_filename() {
            return bed_filename;
        }

        public void setBed_filename(String bed_filename) {
            this.bed_filename = bed_filename;
        }
    }

    class DualIdx {
        public int splitVariantIndex;
        public int wholeVariantIndex;

        /**
         * constructor for this class given known splitVariantIndex and wholeVariantIndex
         * @param splitVariantIndex
         * @param wholeVariantIndex
         */
        DualIdx(int splitVariantIndex, int wholeVariantIndex) {
            this.splitVariantIndex = splitVariantIndex;
            this.wholeVariantIndex = wholeVariantIndex;
        }

        /**
         * initialize to -1 which means no valid variant available
         */
        DualIdx() {
            splitVariantIndex = -1;
            wholeVariantIndex = -1;
        }

        public boolean equals(Object obj) {
            if (obj == null)
                return false;
            if (obj == this)
                return true;
            if (!(obj instanceof DualIdx))
                return false;

            // use EqualsBuilder?
            DualIdx temp = (DualIdx) obj;
            if (splitVariantIndex != temp.splitVariantIndex) {
                return false;
            }

            return wholeVariantIndex == temp.wholeVariantIndex;

        }

        @Override
        public String toString() {
            return "DualIdx{" +
                    "splitVariantIndex=" + splitVariantIndex +
                    ", wholeVariantIndex=" + wholeVariantIndex +
                    '}';
        }
    }

    class ResultComparator {

        chrSearchTree<ValueInterval1D<Variant>> trueVariantIntervalTree; // true variants
        double overlapRatio;
        boolean overlapComplex;
        int wiggle;
        boolean ignoreInsertionLength;

        // Results to store
        // this stores the indexes of the true variants matched
        ArrayList<DualIdx> homozygousMatches = new ArrayList<>();
        ArrayList<ArrayList<DualIdx>> heterozygousMatches = new ArrayList<>(2); // matches either parent

        public ResultComparator(chrSearchTree<ValueInterval1D<Variant>> trueVariantIntervalTree, double overlapRatio, int wiggle, boolean ignoreInsLen) {
            this.trueVariantIntervalTree = trueVariantIntervalTree;
            this.overlapRatio = overlapRatio;
            this.wiggle = wiggle;

            heterozygousMatches.add(new ArrayList<DualIdx>());
            heterozygousMatches.add(new ArrayList<DualIdx>());
            overlapComplex = false;
            ignoreInsertionLength = ignoreInsLen;
        }

        /**
         * return homozygous match (empty if no match)
         * @return
         */
        public DualIdx isHomMatch() {
            if (homozygousMatches.size() > 0) {
                return homozygousMatches.get(0);
            }
            return new DualIdx();
        }

        /**
         * return heterozygous match (empty if no match)
         * @return
         */
        public DualIdx isHetMatch() {
            ArrayList<DualIdx> temp = new ArrayList<>(heterozygousMatches.get(0));
            temp.retainAll(heterozygousMatches.get(1)); //essentially get intersection
            //if there is a match in intersection, return the first one from the intersection
            if (temp.size() > 0) {
                return temp.get(0);
              /*
              if no match in intersection, return the first one from the larger list (the genotype
              containing more heterozygous matches).
              since ResultComparator is created for each variant, heterzygousMatches will only
              store matches for one variant against some true variants. Therefore, I think
              one of the lists in heterozygousMatches will always be zero if there is no intersection
              between them. And in such cases, we just return whatever we have in matches.

              an example, compare these two lines:
              1	993	rs35493185	C	CA	.	.	SVLEN=1	GT	1|0
              1	993	rs35493185	C	CA	.	.	SVLEN=1	GT	1|0

               */
            } else if (heterozygousMatches.get(0).size() > 0 || heterozygousMatches.get(1).size() > 0) {
                if (heterozygousMatches.get(0).size() > heterozygousMatches.get(1).size()) {
                    return heterozygousMatches.get(0).get(0);
                } else {
                    return heterozygousMatches.get(1).get(0);
                }
            }
            return new DualIdx();
        }

        /**
         * determine if there is a match regardless of genotype
         * @return
         */
        public DualIdx isMatch() {
            DualIdx idx = isHomMatch();
            if (idx.splitVariantIndex >= 0) {
                return idx;
            }
            idx = isHetMatch();
            if (idx.splitVariantIndex >= 0) {
                return idx;
            }
            return idx;
        }

        /**
         * Only compares one allele at a time
         * - don't match variants in the bitset
         * - if match set the bitset
         *
         * @param variant       variant we want to compare
         * @param genotype      allele of the variant to compare
         * @param validated BitSet that records the true variants that have already been validated
         * @return The maximum length of all true variants
         */
        public int compareVariant(Variant variant, int genotype, BitSet validated) {
            double overlapRatio = this.overlapRatio;
            // consider type to change overlap percent
            VariantType type = variant.getType(genotype);
            ChrString chr = variant.getChr();
            SimpleInterval1D intervalForCompare;
            if (type == VariantType.Insertion && ignoreInsertionLength) {
                intervalForCompare = new SimpleInterval1D(variant.getPos(), variant.getPos());
            } else {
                intervalForCompare = variant.getVariantInterval(genotype);
            }

            int maxTrueVarianLength = 0;

            // sometimes MNPs are called as SNPs?
            if (type == VariantType.SNP) {
                // handle SNPs differently
                // require SNP content to match
                Iterable<ValueInterval1D<Variant>> overlaps = trueVariantIntervalTree.getOverlaps(chr, intervalForCompare);

                byte alternativeAlleleFirstBase = variant.getAlt(genotype).getSequence()[0];

                int numberOfSnpMatches = 0;
                if (overlaps != null) {
                    for (ValueInterval1D<Variant> trueVariantInterval : overlaps) {
                        Variant trueVariant = trueVariantInterval.getContent();
                        boolean hasSnp = false;
                        int splitVariantIndex = trueVariant.splitVariantIndex;
                        int wholeVariantIndex = trueVariant.wholeVariantIndex;

                        if (trueVariant.originalType == VariantOverallType.Complex) {
                            //System.err.println("Overlap complex SNP!");
                            overlapComplex = true;
                        }

                        if (validated.get(splitVariantIndex)) {
                            // skip ones already validated
                            continue;
                        }

                        // check genotype
                        if (trueVariant.isHom()) {
                            // position is correct, check genotype
                            if (trueVariant.getType(trueVariant.getGoodPaternal()) == VariantType.SNP
                                    && variant.getPos() == trueVariant.getPos()) {
                                if (alternativeAlleleFirstBase == trueVariant.getAlt(trueVariant.getGoodPaternal()).getSequence()[0]) {
                                    homozygousMatches.add(new DualIdx(splitVariantIndex, wholeVariantIndex));
                                }
                                hasSnp = true;
                            }
                        } else {
                            for (int parent = 0; parent < 2; parent++) {
                                int allele = trueVariant.getAllele(parent);
                                //true variant is heterozygous, so only one allele has non-reference sequence
                                if (allele > 0) {
                                    if (trueVariant.getType(allele) == VariantType.SNP
                                            && variant.getPos() == trueVariant.getPos()) {
                                        if (alternativeAlleleFirstBase == trueVariant.getAlt(allele).getSequence()[0]) {
                                            heterozygousMatches.get(parent).add(new DualIdx(splitVariantIndex, wholeVariantIndex));
                                        }
                                        hasSnp = true;
                                    }
                                }
                            }
                        }

                        if (hasSnp) {
                            numberOfSnpMatches++;
                            maxTrueVarianLength = 1;
                        }
                    }

                    if (numberOfSnpMatches > 1) {
                        log.info("Something strange, multiple SNP matches in true set: " + numberOfSnpMatches);
                    }
                }
            } else {
                // Non-SNPs
                SimpleInterval1D intervalForCompareWithWiggle = new SimpleInterval1D(intervalForCompare.left - wiggle, intervalForCompare.right + wiggle);
                Iterable<ValueInterval1D<Variant>> overlaps = trueVariantIntervalTree.getOverlaps(chr, intervalForCompareWithWiggle);


                if (overlaps == null) {
                    // nothing found
                    return maxTrueVarianLength;
                }

                for (ValueInterval1D<Variant> trueVariantInterval : overlaps) {
                    Variant trueVariant = trueVariantInterval.getContent();
                    int splitVariantIndex = trueVariant.splitVariantIndex;
                    int wholeVariantIndex = trueVariant.wholeVariantIndex;

                    if (trueVariant.originalType == VariantOverallType.Complex) {
                        overlapComplex = true;
                    }

                    if (validated.get(splitVariantIndex)) {
                        // skip ones already validated
                        //System.err.println("Skip..." + splitVariantIndex);
                        continue;
                    }

                    //all genotypes in the overlapping true variant will be checked
                    for (int parent = 0; parent < 2; parent++) {
                        if (trueVariant.isHom() && parent == 1) {
                            break;
                        }

                        int allele = trueVariant.getAllele(parent);

                        if (allele == 0) {
                            // reference allele
                            continue;
                        }

                        if (type != trueVariant.getType(allele)) {
                            // need type to be the same
                            continue;
                        }

                        boolean matched = false;

                        if (type == VariantType.Insertion && ignoreInsertionLength) {
                            // this is the case where we want to ignore insertion lengths when comparing
                            // just do a check of the start position

                            if (Math.abs(trueVariant.getPos() - variant.getPos()) <= wiggle) {
                                // Matches!
                                if (trueVariant.isHom()) {
                                    homozygousMatches.add(new DualIdx(splitVariantIndex, wholeVariantIndex));
                                } else {
                                    heterozygousMatches.get(parent).add(new DualIdx(splitVariantIndex, wholeVariantIndex));
                                }
                                matched = true;
                            }
                        } else {
                            // this is the normal case
                            // check if the variant interval matches
                            if (intervalForCompare.intersects(trueVariant.getVariantInterval(allele), overlapRatio, wiggle)) {
                                // it matches an allele!
                                // now check alternate allele length
                                int alternativeAlleleLength = variant.getAlt(genotype).length(); // TODO ignore copy number for now
                                int trueAlternativeAllele = trueVariant.getAlt(allele).length();
                                double ratio = (alternativeAlleleLength > 0) ? (trueAlternativeAllele / (double) alternativeAlleleLength) : 1.0;
                                double minRatio = Math.min(ratio, 1 / ratio);
                                if (minRatio >= overlapRatio || Math.abs(alternativeAlleleLength - trueAlternativeAllele) < wiggle) {
                                    // yay, it is a match!
                                    if (trueVariant.isHom()) {
                                        homozygousMatches.add(new DualIdx(splitVariantIndex, wholeVariantIndex));
                                    } else {
                                        heterozygousMatches.get(parent).add(new DualIdx(splitVariantIndex, wholeVariantIndex));
                                    }
                                    matched = true;
                                }
                            }
                        }

                        if (matched) {
                            int len = trueVariant.maxLen(allele);
                            if (len > maxTrueVarianLength) {
                                maxTrueVarianLength = len;
                            }
                        }
                    }
                }

            }

            return maxTrueVarianLength;
        }
    }

}
